<!DOCTYPE html>
<html>
  <head>
    <title>Morphogenesis</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="d3.v3.js"></script>
    <script type="text/javascript" src="underscore.js"></script>
    <link type="text/css" rel="stylesheet" href="voronoi.css"/>
    <!--:syn sync fromstart-->
  </head>
  <body>
    <input id='zoomin' type='button' onclick='splitAllNodes()' value = '+' />
    <input id='plause' type='button' style="width:5em" onclick='stop()' value='pause' />
    <input id='generating' type='button' style="width:9em" onclick='stopGen()' value='stop generating' />

    <ul id="casting">
      Casting:
      <li><label><input type="radio" name="casting" value="multi" checked="checked"/>Multi Cast</li>
      <li><label><input type="radio" name="casting" value="mono"/>Mono Cast</li>
      <li><label><input type="radio" name="casting" value="monoToEdge"/>Random Walk Until Reaching An Edge Cell</li>
    </ul>

    <br />
    <script type="text/javascript">

//TODO:
//      Create head nodes at the first encountered edge cell's location.
//      - which have gravity to each-other, but mesh with everything else.
//      - also, they should look different.
//      Fix the edge-cases (at borders, sometimes) where nodes are shown to be neighbours, when they actually are not neighbours.

//      Allow nodes to choose their state depending on the state of their neighbours.
//      - make this easy to work with a nice architecture.

//      Implement the following:
//      Cell differentiation: These are the options we see in nature
//      1. Symmetric cell division --> two identical cells
//      2. Asymmetric cell division --> two daughter cells of different types (also different from the mother cell)
//      3. Stem cell asymmetric division --> one daughter like the mother, the other different
//      4. No cell division --> mysterious process called "induction". Changes the cell to a new type

//      1. A -> A, A [done]
//      2. A -> B, C []
//      3. A -> A, B [done]
//      4. A -> B    [done]


var generating = false;
var paused = false;
var startingQuantity = 0; //6 is best
var nbz = [];

document.getElementById('generating').value = generating ? 'stop generating' : 'start simulation';
document.getElementById('plause').value = paused ? 'play' : 'pause';

var w = 860,
    h = 430,
    fill = d3.scale.category10(),
    nodes = [], // this is treated like a global variable
    foci = {x: w/2, y: h/2};
    cellradius = 32; //32 for charge strength of -30, distance of 20, and gravity 0.05
    nucleusradius = 7;

var vis = d3.select("body").append("svg:svg")
    .attr("width", w)
    .attr("height", h)
    .attr("class", "PiYG");

//defaults: size 1×1
//          friction 0.9
//          distance 20
//          charge strength -30
//          gravity strength 0.1
//          and theta parameter 0.8
var force = d3.layout.force()
    .nodes(nodes)
    //.linkDistance(0) // this affected nothing
    .links([])
    .friction(0.85)
    .gravity(0.05)
    .size([w, h]);

    var clips = vis.append("svg:clipPath");


//// TICK ////

force.on("tick", function(e) {
  // ENTER voronoi //
  vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; })))
    .enter().append("path")
    .attr("clip-path", function (d, i) { return "url(#clip"+i+")"; })
    .attr("class", function(d, i) { return i ? "q" + (i % 9) + "-9" : null; })
    .on("mouseover", function (d, i) { return highlightNeighboursIncludingSlef(i); })
    .on("click", function (d, i) { return cloock(i); })
    .style("stroke", "#aaa")
    .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

  // UPDATE voronoi //
  vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; }))
      .map(function(d) { return "M" + d.join("L") + "Z"; }))
      .filter(function(d) { return this.getAttribute("d") != d; })
      .attr("d", function(d) { return d; });

  // ENTER circles //
  vis.selectAll("circle.node")
      .data(nodes)
    .enter().append("svg:circle")
    .attr("class", "node")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", nucleusradius)
      .style("stroke", function(d) { return d3.rgb(fill(0)).darker(2); })
      .style("stroke-width", 1.5)
      .style("fill", function(d) { d.color = "#2E89FF"; return d.color; })
      .call(force.drag);

  // UPDATE circles //
  vis.selectAll("circle.node")
    .attr("cx", function (d) { return d.x; })
    .attr("cy", function (d) { return d.y; })
    .attr("fill", function (d) { return d.color; });

  // DELETE AND THEN ENTER clipping regions //
  vis.selectAll(".clipper")
    .remove(); // TODO: why do I have to delete them all in order to fix this ???
               //       why can't I just move around clipPaths ?
  vis.selectAll(".clipper")
      .data(nodes)
    .enter().append("svg:clipPath")
      .attr("id", function (d, i) { return "clip"+i; })
      .attr("class", "clipper")
      .append("svg:circle")
        .attr('cx', function (d) { return d.x; })
        .attr('cy', function (d) { return d.y; })
        .attr('r', cellradius);
});


//// INITIAL SETUP ////

vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; })))
  .enter().append("path")
    .attr("class", function(d, i) { return i ? "q" + (i % 9) + "-9" : null; })
    .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

var incrementer = -1

// set up interval of generation
setInterval(addNodeIfGen, 1000);

console.log("===Simulation Started===");


//// INTERFACE ////

function cloock (index) {
  var b = document.querySelector("#casting input:checked").value;
  if (b.localeCompare("mono") === 0) {
    propagateOneToOne(index);
  } else if (b.localeCompare("multi") === 0){
    propagateOneToAll(index);
  } else if (b.localeCompare("monoToEdge") === 0){
    propagateMonoToEdge(index);
  } else {
    console.log("UNIMPLEMENTED")
  }
}

var stopGen = function () {
  if (generating === false) {
    generating = true;
    document.getElementById('generating').value = "stop simulation";
  }else{
    generating = false;
    document.getElementById('generating').value = "start simulation";
  }
}

var stop = function () {
  if (paused === false) {
    paused = true;
    force.stop();
    document.getElementById('plause').value = "play";
  }else{
    paused = false;
    force.start();
    document.getElementById('plause').value = "pause";
  }
}


//// CHANGING STATE ////

function highlightSelf (nodeOfInterestIndex, col) {
  vis.selectAll("circle.node")
    //.transition().duration(500)
      .style("fill", function(d,i) {
        if (i == nodeOfInterestIndex) { d.color = col; return d.color; }
        else { return d.color; }
      })
      //.attr("r", function (d, i) { return (i === nodeOfInterestIndex) ? nucleusradius * 2 : nucleusradius})
      ;//.each("end", function () { d3.select(this).transition().duration(500).attr("r", nucleusradius); });
}

function highlightNeighboursIncludingSlef  (nodeOfInterestIndex) {
  var neighbours = generateAllNeighbours()[nodeOfInterestIndex];
  neighbours.push(nodeOfInterestIndex);
  vis.selectAll("circle.node")
    .style("fill", function(d,i) {
      if (i === nodeOfInterestIndex) { d.color = "#CB2EFF"; return d.color; };
      d.color = (neighbours.indexOf(i) > -1) ? "#0DE" : "#2E89FF";
      return d.color;
    });
}

function highlightNeighbours (nodeOfInterest, nodeOfInterestIndex) {
  var neighbours = generateAllNeighbours()[nodeOfInterestIndex];
  vis.selectAll("circle.node")
        .style("fill", function(d,i) { return (neighbours.indexOf(i) > -1) ? "#F0F" : "#0FF"; });
}


//// PROPAGATING ////

function propagateOneToAll (index) {
  //console.log("proping: " + index);
  neighbours = generateAllNeighbours()[index];
  neighbours = _.filter(neighbours, function (d) { return nodes[d].color.localeCompare("#CB2EFF") !== 0; });

  if (!paused && neighbours.length > 0) {
    _.forEach(neighbours, function (d,i) {
      highlightSelf(d, "#CB2EFF");
      setTimeout(propagateOneToAll, 1000, d);
    });
  }
}

function propagateOneToOne (index) {
  //console.log("proping: " + index);
  neighbours = generateAllNeighbours()[index];
  neighbours = _.filter(neighbours, function (d) { return nodes[d].color.localeCompare("#CB2EFF") !== 0; });
  rndm = _.random(0, neighbours.length - 1);
  if (!paused && neighbours.length > 0) {
    highlightSelf(neighbours[rndm], "#CB2EFF");
    setTimeout(propagateOneToOne, 1000, [neighbours[rndm]]);
  }
}

function propagateMonoToEdge (index) {
  //console.log("proping: " + index);
  neighbours = generateAllNeighbours()[index];
  rndm = _.random(0, neighbours.length - 1);
  if (checkIfEdge(index)) {
    console.log("DONE");
    highlightSelf(index, "#FFFFFF");
  } else if (!paused && neighbours.length > 0) {
    highlightSelf(neighbours[rndm], "#CB2EFF");
    //highlightSelf(neighbours[rndm], "#FFFFFF");
    setTimeout(propagateMonoToEdge, 1000, [neighbours[rndm]]);
  }
}


//// ADDING AND REMOVING NODES ////

var addNode = function (indexOfNodeToMultiply) {
  if (paused === false){
    var rad = Math.random() * Math.PI * 2;
    var xoffset = Math.cos(rad) * nucleusradius;
    var yoffset = Math.sin(rad) * nucleusradius;

    // spawn a new node nucleusradius away from the previous node in a random direction.
    nodes.push({ // push a new node at the location of the previous one
      x: (incrementer === -1) ? foci.x : nodes[indexOfNodeToMultiply].x + xoffset,
      y: (incrementer === -1) ? foci.y : nodes[indexOfNodeToMultiply].y + yoffset,
      color: "#2E89FF",
    }); //{id: ~~(Math.random())});

    incrementer++;
    force.start();
  }
};

var addNewNodeToEndOfList = function () {
  addNode(incrementer);
}

var splitAllNodes = function () {
  // split every node into two nodes
  var i = 0;
  incNow = incrementer + 1;

  //for every node, make a new node
  for (i = 0; i < incNow; i++) {
    addNode(i);
  }
};

var addNodeIfGen = function () {
  if (generating) { addNewNodeToEndOfList(); }
}


//// HELPER METHODS ////

function generateAllNeighbours () {
  return d3.get_delaunay_neighbours(_.map(nodes, function (d) { return [Math.round(d.x), Math.round(d.y)]; }))
}

function countNeighbours (index) {
  return generateAllNeighbours()[index].length;
}

function checkIfEdge (index) {
  //Not a perfect method, but it will do for our purposes:
  // We know that it is very rare that a non-edge cell can have less than 5 neighbours,
  // also, some edge cells have 5 or more neighbours.
  return countNeighbours(index) < 5;
}

// set up the initial mass (mostly for testing)
_.times(1, addNewNodeToEndOfList);
_.times(startingQuantity, splitAllNodes);

    </script>
  </body>
</html>
