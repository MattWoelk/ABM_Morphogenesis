<!DOCTYPE html>
<html>
  <head>
    <title>Morphogenesis</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="d3.v2.js"></script>
    <script type="text/javascript" src="underscore.js"></script>
    <link type="text/css" rel="stylesheet" href="voronoi.css"/>
  </head>
  <body>
    <input id='zoomin' type='button' onclick='split_all_nodes()' value = '+' />
    <input id='plause' type='button' style="width:5em" onclick='stop()' value='pause' />
    <input id='generating' type='button' style="width:9em" onclick='stop_gen()' value='stop generating' />
    <br />
    <script type="text/javascript">

//TODO: suppress warnings from voronoi, or make it happy some other way
//      - better to make it happy, that way we can have a single cell looking good, too.
//      add the ability to zoom in on the plot, or change the size of the nucleus or cells.
//      - maybe with some nice sliders or something.
//      Fix the edge-cases (at borders, sometimes) where nodes are shown to be neighbours, when they actually are not neighbours.
//      Make a better data structure for the nodes.
//      - properties: color, neighbours, maybe other things

var generating = false;
var toggle = false;
var startingQuantity = 6;
var nbz = [];

document.getElementById('generating').value = generating ? 'stop generating' : 'start simulation';
document.getElementById('plause').value = toggle ? 'play' : 'pause';

var w = 860,
    h = 430,
    fill = d3.scale.category10(),
    nodes = [],
    foci = {x: w/2, y: h/2};
    cellradius = 32; //32 for charge strength of -30, distance of 20, and gravity 0.05
    nucleusradius = 7;

var vis = d3.select("body").append("svg:svg")
    .attr("width", w)
    .attr("height", h)
    .attr("class", "PiYG");

//defaults: size 1×1
//          friction 0.9
//          distance 20
//          charge strength -30
//          gravity strength 0.1
//          and theta parameter 0.8
var force = d3.layout.force()
    .nodes(nodes)
    //.linkDistance(0) // this affected nothing
    .links([])
    .friction(0.85)
    .gravity(0.05)
    .size([w, h]);

    var clips = vis.append("svg:clipPath");

force.on("tick", function(e) {
  // ENTER voronoi //
  vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; })))
    .enter().append("path")
    .attr("clip-path", function (d, i) { return "url(#clip"+i+")"; })
    .attr("class", function(d, i) { return i ? "q" + (i % 9) + "-9" : null; })
    .on("mouseover", function (d, i) { return highlight_neighbours_including_self(i); })
    .on("click", function (d, i) { return cloock(i); })
    .style("stroke", "#aaa")
    .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

  // UPDATE voronoi //
  vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; }))
      .map(function(d) { return "M" + d.join("L") + "Z"; }))
      .filter(function(d) { return this.getAttribute("d") != d; })
      .attr("d", function(d) { return d; });

  // ENTER circles //
  vis.selectAll("circle.node")
      .data(nodes)
    .enter().append("svg:circle")
    .attr("class", "node")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", nucleusradius)
      .style("stroke", function(d) { return d3.rgb(fill(0)).darker(2); })
      .style("stroke-width", 1.5)
      .style("fill", "#2E89FF")
      .call(force.drag);

  // UPDATE circles //
  vis.selectAll("circle.node")
    .attr("cx", function (d) { return d.x; })
    .attr("cy", function (d) { return d.y; });

  // DELETE AND THEN ENTER clipping regions //
  vis.selectAll(".clipper")
    .remove(); // TODO: why do I have to delete them all in order to fix this ???
               //       why can't I just move around clipPaths ?
  vis.selectAll(".clipper")
      .data(nodes)
    .enter().append("svg:clipPath")
      .attr("id", function (d, i) { return "clip"+i; })
      .attr("class", "clipper")
      .append("svg:circle")
        .attr('cx', function (d) { return d.x; })
        .attr('cy', function (d) { return d.y; })
        .attr('r', cellradius);
});


vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; })))
  .enter().append("path")
    .attr("class", function(d, i) { return i ? "q" + (i % 9) + "-9" : null; })
    .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

var incrementer = -1

var add_node = function (index_of_node_to_multiply) {
  if (toggle === false){
    var rad = Math.random() * Math.PI * 2;
    var xoffset = Math.cos(rad) * nucleusradius;
    var yoffset = Math.sin(rad) * nucleusradius;

    // spawn a new node nucleusradius away from the previous node in a random direction.
    nodes.push({ // push a new node at the location of the previous one
      x: (incrementer === -1) ? foci.x : nodes[index_of_node_to_multiply].x + xoffset,
      y: (incrementer === -1) ? foci.y : nodes[index_of_node_to_multiply].y + yoffset
    }); //{id: ~~(Math.random())});

    incrementer++;
    force.start();
  }
};

var add_new_node_to_end_of_list = function () {
  add_node(incrementer);
}

// split every node into two nodes
var split_all_nodes = function () {
  //for every node, make a new node
  var i = 0;
  inc_now = incrementer + 1;
  for (i = 0; i < inc_now; i++) {
    add_node(i);
  }
};

var addNodeIfGen = function () {
  if (generating) { add_new_node_to_end_of_list(); }
}

var stop_gen = function () {
  if (generating === false) {
    generating = true;
    document.getElementById('generating').value = "stop simulation";
  }else{
    generating = false;
    document.getElementById('generating').value = "start simulation";
  }
}

var stop = function () {
  if (toggle === false) {
    toggle = true;
    force.stop();
    document.getElementById('plause').value = "play";
  }else{
    toggle = false;
    force.start();
    document.getElementById('plause').value = "pause";
  }
}

// set up interval of generation
setInterval(addNodeIfGen, 1000);

function highlight_self (node_of_interest_index) {
  vis.selectAll("circle.node")
    .style("fill", function(d,i) {
      if (i === node_of_interest_index) { return "#CB2EFF"; }
      else { return "#2E89FF"; }
    });
}

function highlight_neighbours_including_self  (node_of_interest_index) {
  var neighbours = generate_all_neighbours()[node_of_interest_index];
  neighbours.push(node_of_interest_index);
  vis.selectAll("circle.node")
    .style("fill", function(d,i) {
      if (i === node_of_interest_index) { return "#CB2EFF"; };
      return (neighbours.indexOf(i) > -1) ? "#0DE" : "#2E89FF";
    });
}


function highlight_neighbours (node_of_interest, node_of_interest_index) {
  var neighbours = generate_all_neighbours()[node_of_interest_index];
  vis.selectAll("circle.node")
        .style("fill", function(d,i) { return (neighbours.indexOf(i) > -1) ? "#F0F" : "#0FF"; });
}

console.log("===Simulation Started===");

function generate_all_neighbours () {
  return d3.get_delaunay_neighbours(_.map(nodes, function (d) { return [Math.round(d.x), Math.round(d.y)]; }))
}

function cloock (index) {
  propagate_one_to_one(index);
}

function propagate_one_to_one (index) {
  console.log("proping: " + index);
  neighbours = generate_all_neighbours()[index];
  rndm = _.random(0, neighbours.length - 1);
  highlight_self(neighbours[rndm]);
  if (!toggle) {
    setTimeout(propagate_one_to_one, 1000, [neighbours[rndm]]);
  }
}

// set up the initial mass (mostly for testing)
_.times(1, add_new_node_to_end_of_list);
_.times(startingQuantity, split_all_nodes);

    </script>
  </body>
</html>
