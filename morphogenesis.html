<!DOCTYPE html>
<html>
  <head>
    <title>Morphogenesis</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="d3.v3.js"></script>
    <script type="text/javascript" src="underscore.js"></script>
    <link type="text/css" rel="stylesheet" href="voronoi.css"/>
  </head>
  <body>
    <input id='zoomin' type='button' onclick='split_all_nodes()' value = '+' />
    <input id='plause' type='button' style="width:5em" onclick='stop()' value='pause' />
    <input id='generating' type='button' style="width:9em" onclick='stop_gen()' value='stop generating' />

    <ul id="casting">
      Casting:
      <li><label><input type="radio" name="casting" value="multi" checked="checked"/>Multi Cast</li>
      <li><label><input type="radio" name="casting" value="mono"/>Mono Cast</li>
    </ul>

    <br />
    <script type="text/javascript">

//TODO:
//      add the ability to zoom in on the plot, or change the size of the nucleus or cells.
//      - maybe with some nice sliders or something.
//      Fix the edge-cases (at borders, sometimes) where nodes are shown to be neighbours, when they actually are not neighbours.

//      Implement the following:
//      Cell differentiation: These are the options we see in nature
//      1. Symmetric cell division --> two identical cells
//      2. Asymmetric cell division --> two daughter cells of different types (also different from the mother cell)
//      3. Stem cell asymmetric division --> one daughter like the mother, the other different
//      4. No cell division --> mysterious process called "induction". Changes the cell to a new type

//      1. A -> A, A [done]
//      2. A -> B, C []
//      3. A -> A, B [done]
//      4. A -> B    [done]


var generating = false;
var paused = false;
var startingQuantity = 0; //6 is best
var nbz = [];

document.getElementById('generating').value = generating ? 'stop generating' : 'start simulation';
document.getElementById('plause').value = paused ? 'play' : 'pause';

var w = 860,
    h = 430,
    fill = d3.scale.category10(),
    nodes = [],
    foci = {x: w/2, y: h/2};
    cellradius = 32; //32 for charge strength of -30, distance of 20, and gravity 0.05
    nucleusradius = 7;

var vis = d3.select("body").append("svg:svg")
    .attr("width", w)
    .attr("height", h)
    .attr("class", "PiYG");

//defaults: size 1×1
//          friction 0.9
//          distance 20
//          charge strength -30
//          gravity strength 0.1
//          and theta parameter 0.8
var force = d3.layout.force()
    .nodes(nodes)
    //.linkDistance(0) // this affected nothing
    .links([])
    .friction(0.85)
    .gravity(0.05)
    .size([w, h]);

    var clips = vis.append("svg:clipPath");

force.on("tick", function(e) {
  // ENTER voronoi //
  vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; })))
    .enter().append("path")
    .attr("clip-path", function (d, i) { return "url(#clip"+i+")"; })
    .attr("class", function(d, i) { return i ? "q" + (i % 9) + "-9" : null; })
    .on("mouseover", function (d, i) { return highlight_neighbours_including_self(i); })
    .on("click", function (d, i) { return cloock(i); })
    .style("stroke", "#aaa")
    .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

  // UPDATE voronoi //
  vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; }))
      .map(function(d) { return "M" + d.join("L") + "Z"; }))
      .filter(function(d) { return this.getAttribute("d") != d; })
      .attr("d", function(d) { return d; });

  // ENTER circles //
  vis.selectAll("circle.node")
      .data(nodes)
    .enter().append("svg:circle")
    .attr("class", "node")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", nucleusradius)
      .style("stroke", function(d) { return d3.rgb(fill(0)).darker(2); })
      .style("stroke-width", 1.5)
      .style("fill", function(d) { d.color = "#2E89FF"; return d.color; })
      .call(force.drag);

  // UPDATE circles //
  vis.selectAll("circle.node")
    .attr("cx", function (d) { return d.x; })
    .attr("cy", function (d) { return d.y; })
    .attr("fill", function (d) { return d.color; });

  // DELETE AND THEN ENTER clipping regions //
  vis.selectAll(".clipper")
    .remove(); // TODO: why do I have to delete them all in order to fix this ???
               //       why can't I just move around clipPaths ?
  vis.selectAll(".clipper")
      .data(nodes)
    .enter().append("svg:clipPath")
      .attr("id", function (d, i) { return "clip"+i; })
      .attr("class", "clipper")
      .append("svg:circle")
        .attr('cx', function (d) { return d.x; })
        .attr('cy', function (d) { return d.y; })
        .attr('r', cellradius);
});


vis.selectAll("path")
    .data(d3.geom.voronoi(_.map(nodes, function (d) { return [d.x, d.y]; })))
  .enter().append("path")
    .attr("class", function(d, i) { return i ? "q" + (i % 9) + "-9" : null; })
    .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

var incrementer = -1

var add_node = function (index_of_node_to_multiply) {
  if (paused === false){
    var rad = Math.random() * Math.PI * 2;
    var xoffset = Math.cos(rad) * nucleusradius;
    var yoffset = Math.sin(rad) * nucleusradius;

    // spawn a new node nucleusradius away from the previous node in a random direction.
    nodes.push({ // push a new node at the location of the previous one
      x: (incrementer === -1) ? foci.x : nodes[index_of_node_to_multiply].x + xoffset,
      y: (incrementer === -1) ? foci.y : nodes[index_of_node_to_multiply].y + yoffset,
      color: "#2E89FF",
    }); //{id: ~~(Math.random())});

    incrementer++;
    force.start();
  }
};

var add_new_node_to_end_of_list = function () {
  add_node(incrementer);
}

// split every node into two nodes
var split_all_nodes = function () {
  //for every node, make a new node
  var i = 0;
  inc_now = incrementer + 1;
  for (i = 0; i < inc_now; i++) {
    add_node(i);
  }
};

var addNodeIfGen = function () {
  if (generating) { add_new_node_to_end_of_list(); }
}

var stop_gen = function () {
  if (generating === false) {
    generating = true;
    document.getElementById('generating').value = "stop simulation";
  }else{
    generating = false;
    document.getElementById('generating').value = "start simulation";
  }
}

var stop = function () {
  if (paused === false) {
    paused = true;
    force.stop();
    document.getElementById('plause').value = "play";
  }else{
    paused = false;
    force.start();
    document.getElementById('plause').value = "pause";
  }
}

// set up interval of generation
setInterval(addNodeIfGen, 1000);

function highlight_self (node_of_interest_index) {
  vis.selectAll("circle.node")
    //.transition().duration(500)
      .style("fill", function(d,i) {
        if (i === node_of_interest_index) { d.color = "#CB2EFF"; return d.color; }
        else { return d.color; }
      })
      //.attr("r", function (d, i) { return (i === node_of_interest_index) ? nucleusradius * 2 : nucleusradius})
      ;//.each("end", function () { d3.select(this).transition().duration(500).attr("r", nucleusradius); });
}

function highlight_neighbours_including_self  (node_of_interest_index) {
  var neighbours = generate_all_neighbours()[node_of_interest_index];
  neighbours.push(node_of_interest_index);
  vis.selectAll("circle.node")
    .style("fill", function(d,i) {
      if (i === node_of_interest_index) { d.color = "#CB2EFF"; return d.color; };
      d.color = (neighbours.indexOf(i) > -1) ? "#0DE" : "#2E89FF";
      return d.color;
    });
}


function highlight_neighbours (node_of_interest, node_of_interest_index) {
  var neighbours = generate_all_neighbours()[node_of_interest_index];
  vis.selectAll("circle.node")
        .style("fill", function(d,i) { return (neighbours.indexOf(i) > -1) ? "#F0F" : "#0FF"; });
}

console.log("===Simulation Started===");

function generate_all_neighbours () {
  return d3.get_delaunay_neighbours(_.map(nodes, function (d) { return [Math.round(d.x), Math.round(d.y)]; }))
}

function cloock (index) {
  var b = document.querySelector("#casting input:checked").value;
  if (b.localeCompare("mono") === 0) {
    propagate_one_to_one(index);
  } else {
    propagate_one_to_all(index);
  }
}

function propagate_one_to_all (index) {
  //console.log("proping: " + index);
  neighbours = generate_all_neighbours()[index];
  neighbours = _.filter(neighbours, function (d) { return nodes[d].color.localeCompare("#CB2EFF") !== 0; });

  if (!paused && neighbours.length > 0) {
    _.forEach(neighbours, function (d,i) {
      highlight_self(d);
      setTimeout(propagate_one_to_all, 1000, d);
    });
  }
}

function propagate_one_to_one (index) {
  //console.log("proping: " + index);
  neighbours = generate_all_neighbours()[index];
  neighbours = _.filter(neighbours, function (d) { return nodes[d].color.localeCompare("#CB2EFF") !== 0; });
  rndm = _.random(0, neighbours.length - 1);
  if (!paused && neighbours.length > 0) {
    highlight_self(neighbours[rndm]);
    setTimeout(propagate_one_to_one, 1000, [neighbours[rndm]]);
  }
}

// set up the initial mass (mostly for testing)
_.times(1, add_new_node_to_end_of_list);
_.times(startingQuantity, split_all_nodes);

    </script>
  </body>
</html>
